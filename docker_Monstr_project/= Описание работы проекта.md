# = Запуск докер-проекта с Vue-проектом внутри.
Описание Docker (Vue + Nginx) для Vue-проекта, к слову, есть в Vue-туториале(!). Надо посмотреть.
https://cli.vuejs.org/ru/guide/deployment.html#bitbucket-cloud

#1. Устанавливаем на ноутбук Docker и Docker-compose.

#2. В проекте, везде, где есть package.json, устанавливаем в проект зависимости (это делать не надо)
npm i

Однако это делается автоматически при запуске Dockerfile, которые запускаются by docker-compose.yml, который запускается при старте контейнера.
docker-compose build       //сборка-ПЕРЕСБОРКА образа
docker-compose up          //запуск образа
или
docker-compose up --build  //пересборка и запуск образа


#3. Прописываем псевдонимы для IP-адреса у сети ноутбука (это делать не надо, я довел до ума) (лекция #18.6, #27).
Это необходимо для симуляции production-работы проекта.
Для dev-работы я это переделал, - фронтенд открываем в броузере по url http://localhost:80 или http://localhost/ (см. #27 в "= Шаги семинара").

Итак,
-открываем на компъютере файл 
/etc/hosts
(на windows - c:\windows\system32\drivers\etc\hosts)

-добавляем в него новую строчку
127.0.0.1 http://sw.ru
127.0.0.1 sw.ru

-что бы изменить права доступа к файлу надо, когда терминал открыт по папке /etc, сделать
sudo chmod -R -f 777 ./hosts




# Перед запуском
Если проект уже ранее билдился (создавались контейнеры), но из другого места на компьютере,
то необходимо предварительно эти контейнеры удалить by

>docker ps          //ЗАПУЩЕННЫЕ контейнеры
>docker ps -a       //Все контейнеры в системе (включая остановленные контейнеры)

>docker stop nameConteiner nameConteiner nameConteiner
>docker rm nameConteiner nameConteiner nameConteiner       //можно сразу указать несколько контейнеров

или
>docker stop $(docker ps -a -q)   //остановить ВСЕ контейнеры
>docker rm $(docker ps -a -q)     //удалить ВСЕ контейнеры


Здесь использование команды
>docker-compose down   //Остановить и УДАЛИТЬ контейнеры, сети, изображения и тома
>docker-compose stop   //Остановить службы

недостаточно (ДА), т.к. эти команды останавливают контейнеры только ТЕКУЩЕГО (?) docker-compose.yml файла.




#4. Запуск для production.
Из корня проекта, там, где лежит docker-compose.yml, билдим контейнер и запускаем его
>docker-compose build       //сборка-ПЕРЕСБОРКА образа
>docker-compose up          //запуск образа
> или
>docker-compose up --build

Проект открывается на http://sw.ru



#5. Запуск для dev.
Мы можем редактировать код с горячей перезагрузкой в броузере.
>docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build

Проект открывается на localhost:80 или localhost/ просто.

По большому счету фронт-проект БУДЕТ открываться в броузере и по localhost:3000, что прописано в docker-compose.yml.
Но тогда axios-запрос axios.get('/api'), являясь stateless-ным, будет направляться по адресу localhost:3000/api и
не попадет в ngnix, который слушает :80-порт, а попадет непосредственно в порты, прописанные у сервисов в docker-compose.yml,
а там на :3000 висит сервис frontend. А нам требуется попасть к api-сервису, который слушает 3001-порт...,
и поэтому axios-запрос не найдет свою цель.

Здесь же - stateless-запрос будет захватяваться by :80 портом, который слушает nginx.
А nginx, в свою очередь, перенаправит запрос в api-сервис.
Все работать будет.


# Остановка докера.
Ctrl + C

docker-compose down   //Остановить и УДАЛИТЬ контейнеры, сети, изображения и тома
docker-compose stop   //Остановить службы



##################
# = ОПИСАНИЕ работы докер-проекта.

# A. Общее.
1. docker-compose.yml запускает все Docker файлы, которые присутствуют у всех отдельных сервисов.
>docker-compose build       //сборка-ПЕРЕСБОРКА образа
>docker-compose up          //запуск образа
или
>docker-compose up --build

По каждому сервису будет строиться 2 образа
- стартовый образ, который прописан by FROM в Dockerfile у данного сервиса
- образ сервиса собственно

Наличие созданных образов можно проверить командой
>docker images            //список всех обазоов



2. В environment у сервисов в docker-compose.yml мы можем задавать системные переменные для ДАННОГО сервиса,
а потом обращаться к ним в файлах ДАННОГО сервиса через
process.env.varName

А еще лучше эти переменные декларировать в отдельном файле
и тогда эти переменные будут попадать не только в node, но и во Vue(!). Но как это делать, я не знаю.



3. Мы можем не создавать Dockerfile для сервиса, 
и даже не создавать для файлов сервиса отдельную папку, ибо файлов здесь не будет,
а напрямую в docker-compose.yml пропишем стандартный, уже готовый образ с dockerHub'a (см. #10), БЕЗ ДОДЕЛКИ его.
   image: mongo:latest     //image - аналог FROM из Dockerfile.
   
Этот подход используем для создания сервисов (образов), содержащих датабазу mongo, 
ибо для нее уже существует стандартный complete-образ.



4. В docker-compose.yml у сервиса api добавляем:
   depends_on:              //что бы сначало запускался сервис api_db, а лишь затем сервис api
    - api_db



5. Все поля, которые могут быть прописаны в docker-compose.yml, описаны на
https://docs.docker.com/compose/compose-file/
   


6. Можно дополнительно создать второй вариант docker-compose.yml, назвав его docker-compose.development.yml
Поля docker-compose.development.yml перетрут аналогичные поля docker-compose.yml.
Для запуска docker-compose, что бы запустились ОБА: docker-compose.yml и docker-compose.development.yml, пишем

>docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build



# СЕРВИСЫ
Это отдельные проектики, которые могут связываться между собой по докер-сети или by nginx'ом.
В основе сервисов у нас лежит:
Vue-CLI_проект
express-сервер
ngnix


# B. Сервера, встречающиеся в проекте.
- express, nginx и serve(в Dockerfile.prod у frontend)


## nginx 
- для перенаправления запросов ИЗ-ВНЕ (через порт :80) на определенный сервис проекта,
- что бы выступать как единственная точка доступа к проекту для пользователей. 
В этом случае мы сможем использовать stateless-запросы. (см. # Запуск для dev.)

//docker-compose.yml
services:
  frontend:
    ports:
      - "3000:8080"

3000- это тот порт, через который проявляется в докер-сеть frontend-проект.
Однако при наличии nginx'a, эта строчка "ports" в frontend-сервисе СТАНОВИТСЯ НЕВОСТРЕБОВАННОЙ, лишней.
Мы подменяем "ports: "3000:8080"" by nginx-перенаправлением (в nginx.conf.dev или nginx.conf.prod)
 proxy_pass http://frontend:8080;


## serve
нужен для того, чтобы на порту :8080 у front-сервиса выставить сбилденный для продакшина фронт-проект.
"serve" инстиллируется в FRONTEND-часть докер-контейнера ГЕНЕРАЛЬНО by командой из frontend/Dockerfile.prod,
а запускается из docker-compose.yml

services:
  frontend:
    command: serve -s dist -l 8080   

Сбилденный для продакшина фронт-проект (папка dist) откроется на порту :8080, like Vue-CLI,
и к нему будет обращаться nginx по роуту '/'. 
location / {
 proxy_pass http://frontend:8080;
}

Дополнительно, при наличии записи в docker-compose.yml
services:
  frontend:
    ports:
      - "3000:8080"
фронт-проект можно открыть по 
http://localhost:3000/,
но axios-запросы из frontend-проекта достигать цели не будут.



## express
1. express - это сервер, написанный на node.js. 
Он нужен для обработки различных (для разруливания которых и нужен роут, которым обладает сервер) axios-запросовс фронт-проекта, 
далее идет запрос данных из mongoDb и далее
возврат этих данных на фронт.
Его прописываем в docker-compose.yml как сервис "/api".


2. Mongoose - нужен для ТИПИЗАЦИИ коннекта express с MongoDB. 
Но можно обойтись и без Mongoose, а express будет обращаться к MongoDB через одноименную утилиту "mongodb".
Mongoose с помощью своих схем и моделей привносит в нашу работу с MongoDB типизацию данных, которая у MongoDB отсутствует.


Данные будут лежать в базе MongoDB, но для которого в api/src/index.js прописываем (см. #11)
- Schema в коде сервера api/src/index.js
- model схемы на базе Schema
- создаем экземпляр модели с конкретными данными
- сохраняем экземпляр модели в bd   
   
Доступ к данным будет по адресу mongodb://api_db:27017/api, где /api - МЕСТО ХРАНЕНИЯ данных.




## nodemon
нужен для dev-работы, что бы при каждом изменении кода в файлах api-сервиса - express-сервер сразу перезагружался,
Для этого мы используем nodemon внутри express-сервиса.

>npm i nodemon     // устанавливаем, находясь в папке  /api

// api/nodemon.json
{
  "verbose": false,
  "watch": ["src"],             // = на изменение в каких фалах реагировать. src- это папка в сервисе "api"(!).
  "exec": "node src/index.js"   // = какую команду запускать, когда изменяется файл. Здесь- просто перезапускаем express, перезапускаем api-сервис.
}





# C. MongoDB
4. Создаем в docker-compose.yml сервис с MongoDB под именем api_db и auth_db:, 
не создавая при этом для сервиса отдельную папочку. Нет нужды, тк
Dockerfile мы здесь заявлять не будем, он был бы слишком простым- в одну строчку,
а здесь мы используем "упакованный полностью" образ MongoDB, указывая напрямую из docker-compose.yml готовенький образ.
   image: mongo:latest

4. Однако когда мы перебилдиваем образ, то все данные в bd будут обнуляться.
Поэтому сохраняемые данные выносим в volumes данного сервиса, наружу от контейнера,
а так же в общие volumes всего докер-проекта.

   volumes:
    - mongodb_api:/data/db
    - папка, где храниться ........   

volumes:
  mongodb_api:
  mongodb_auth:







#D. Frontend-проект.
Vue-CLI внутри Frontend-сервиса проявляется на Frontend-сервисном порту 8080 (который Frontend-сервис слушает), 
а Frontend-сервис, в свою очередь, демонстрирует Vue-проект наружу себя через порт 3000.

## На dev-режиме 
Vue-CLI запускается из docker-compose.development.yml командой, прописанной в Frontend-сервисе,- command: npm run serve.
Сам код проекта храниться в
volumes:
- ./frontend/src:/usr/src/app/src
- объективная папка докер-проекта : папка в контейнере
- что копируем(где кодим и вносим правки) : куда копируем(что отрабатывает для демонстрации)

После внесений правок в код фронта ПЕРЕЗАПУСК ИДЕТ АВТОМАТИЧЕСКИ по socket vue-CLI ,БЕЗ(!) доп наших усилий.




## На prod-режиме
Сервер "serve", запущенный в Frontend-сервисе, демонстрирует созданную в ходе билда dist-папку тоже через 8080 порт сервиса,
что передается сервисом наружу через тот же самый 3000 порт.











