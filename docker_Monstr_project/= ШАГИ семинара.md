https://monsterlessons.com/project/series/docker-i-docker-compose-deploj-proekta-s-nulya
016@rambler.ru 548655618

Дополнительные комментарии есть в каждом файле проекта. См.

#1. Запуск болванки DOCKER-COMPOS
- пишем простейший docker-compose.yml
version: '3'      <версия docker-compose
services:
  api:            <название одного из наших сервисов
    build: ./api  <Docker-compose запрашивает Dockerfile из папки ./api

a) пишем простейший Dockerfile

FROM node:12
или  
FROM node:13.12.0-alpine
- alpine версия - на основе облегченного Linux и поэтому весит оч мало
- лучше указывать ТОЧНУЮ версию

Образы храняться на
> hub.docker.com
можно там сохранить и свой образ.


b) билдим Docker_compose-образ, находясь в корне проекта, там, где находиться docker-compose.yml, 
>docker-compose build  

билдится образ - скачиваются востребованные для него пакеты,
сбилденный образ храниться где-то локально
Т.е. пустую болванку Dockerfile-Docker_compose - запустили.

Наличие созданного образа можно проверить командой
>docker images            //список всех обазоов
- получим наличие ДВУХ образов:
- образ стартового "node 12 ", который прописан by FROM в Dockerfile
- образ сервиса из docker-compose.yml


#2. Для проекта нам необходимы 7 его частей - services:
frontend                                  - /frontend
API для кода_фронтенда                    - /api
API для процесса авторизации_фронтенда    - /auth
API для bd кода_фронтенда (mongoDb)
API для bd авторизации_фронтенда (mongoDb)
emailer
nginx для прокси-манипуляций

Эти services будем прописывать в docker-compose.yml



#3. Создаем сервер express (routing & server на базе node), пока ВНЕ докера.

1. в /api создаем package.json с помощью команды
>npm init
2. инстиллируем express
>npm i express
3. в /api/src/index.js пишем код express-сервера
4. теперь, если из папки /api запустить 
>npm run node src/index.js

то в консоле увидем колбек от экспресса "Started api service", 
а на порту 3000 - колбек "Our api server is working correctly".

Т.е. сервер, запущенный вне докера, - работает.



#4 Переносим код сервера (наш API-service) внутрь Dockerfile.
- дописываем api/Dockerfile, 
копируем в образ все файлы нашего сервиса, которые расположены в /api.

#5 Прописываем Dockerfile в docker-compose.yml более развернуто
с указанием порта проброски и команды запуска для содержимого данного Dockerfile-образа.

#6 Повторно билдим Docker_compose-образ
>docker-compose build

#7 Запускаем Docker_compose-образ
>docker-compose up

в консоле появиться надпись "Started api service", 
которая должна появляться при запуске express, 
который прописан в Dockerfile, или другими словами, в одном из сервисов Docker-compose,

а в броузере http://localhost:8080/test откроется наша страничка с "Our api server is working correctly".



#8 Остальные поля в docker-compose.yml
Все поля, которые могут быть прописаны в docker-compose.yml, описаны на
https://docs.docker.com/compose/compose-file/


#9 Декларируем переменные окружения для кода, который скопирован в Dockerfile-образ 
т.е. получаем возможность управлять кодом внутри образа, не переписывая его напрямую.
- их декларируем в docker-compose.yml в соответствующем его сервисе (соответствует искомому Dockerfil'у).

//docker-compose.yml - декларируем.
services:
  api:
    command: npm run start
    ports:
      - "8080:3000"
    environment:
      - PORT=3000                   <здесь мы ОБЪЯВИЛИ ПЕРЕМЕННУЮ ОКРУЖЕНИЯ для express
      - HOST=http://sw.ru           <и эту переменную теперь можно вызвать в коде express'a (см).
                                    <HOST и PORT - самостоятельно НЕ ПЕРЕТИРАЮТ значения у ports:"8080:3000" (!).
                                    
А еще лучше эти переменные декларировать в отдельном файле.
И эти переменные будут попадать не только в node, но и во Vue(!).

//Dockerfile - используем.
console.log('PORT', process.env.PORT)
const port = process.env.PORT;          //PORT и HOST мы объявили в docker-compose.yml
const host = process.env.HOST;

A ЕЩЕ ЛУЧШЕ (см. ниже)
при одном и том же наборе Dockerfil'ов мы пишем docker-compose.yml и docker-compose.development.yml - для production и для dev,
- без передачи переменных,
- но прописывая другую команду "command: npm run dev" (для react).

  
  
#//
#10 Add  Mongoose для последующего коннекта с MongoDB.
Для облегчения коннекта MongoDB и node_сервера (express) будем использовать Mongoose.

1. Из папки /api ставим Mongoose
>npm i mongoose
  
2. Подключение Mongoose к серверу.
Если инициацию Mongoose
const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true});

прописать непосредственно в коде express - docker_project/api/src/index.js, 
то мы не будем уверены, что запуститься быстрей- сервер или bd.

Надо сначало создать .connection в DB, и лишь затем запустить сервер.
Поэтому надежней код Mongoose писать в хелпере - /api/src/helpers/db.js, 
запускать его в коде сервера api/src/index.js, 
а когда .connection в Mongoose даст событие .once("open", startServer); ,
то стартуем у сервера его процесс прослушивания порта 3000.
  
3. Прописываем в docker-compose.yml сервис api_db
Здесь мы НЕ будем создавать Dockerfile, а напрямую в docker-compose.yml пропишем стандартный уже готовый образ с dockerHub'a
image: mongo:latest     //image - аналог FROM из Dockerfile.

4. В docker-compose.yml у сервиса api добавляем:
    depends_on:              //что бы сначало запускался сервис api_db, а лишь затем сервис api
      - api_db 
      
5. Прописываем в docker-compose.yml новую системную переменную окружения MONGO_URL для bd
    environment:
      - MONGO_URL=mongodb://api_db:27017/api 
 mongodb - это точка в mongo, любой MONGO_URL начинается с него,
 ей соответствует хост, который докер автоматически сездает для каждого своего сервиса(см. сеть_ докера):
 //api_db:27017/api , где /api - МЕСТО ХРАНЕНИЯ ДАННЫХ.  



#11 Подключаем к Mongoose собственно bd_MongoDB,
https://mongoosejs.com/docs/
Создаем в коде сервера api/src/index.js
- схему
- модель на основе схемы
(см. в коде сервера дополнения типа "//= ...", api/src/index.js)

//=1. Декларация схемы MongoDB, kittySchema- имя произвольное.
const kittySchema = new mongoose.Schema({ name: String });

//=2. Декларация модели MongoDB на базе схемы.
const Kitten = mongoose.model("Kitten", kittySchema);

//=3. Создание экземпляра модели с конкретными данными - Документ.
const silence = new Kitten({ name: "Go!" });  //silence = { _id: 5ef32ed2b2b05f0011099056, name: 'Go!'}

//=4. сохраняем Документ в bd.
silence.save(function(err, savedData) {}) //savedData = { _id: 5ef32ed2b2b05f0011099056, name: 'Go!', __v: 0 }   



#12 Вынос данных bd наружу контейнера, volumes.
ибо когда мы перебилдиваем образ, то все данные в bd будут обнуляться.

1. Дописываем в сервисе api_db у docker-compose.yml
api_db
  volumes:
    - mongodb_api:/data/db

где
mongodb_api - наше произвольное имя томов данных, под этим именем том будет храниться на компьютере.
/data/db    - место в коде образа mongo:latest, где хранятся конкретные данные MongoDB.

Дело в том, что mongo:latest явл слепком Linux с установленным в нем MongoDB.
Так вот, если реально ставить MongoDB в Linux, то данные в Linux'e обычно храняться в его папке /data/db.
Поэтому здесь мы прописываем именно такой путь к сохраняемым данным.

2. На уровне декларации сервисов в docker-compose.yml декларируем имеющиеся volumes
volumes:
  mongodb_api:       //(не забыть : в конце!)

3. перезапускаем docker-compose
>docker-compose up --build

но унас появляется надпись:
WARNING: Service "api_db" is using volume "/data/db" from the previous container.
Поэтому сначало удаляем api_db-образ, а затем билдим docker_compose заново:
>docker-compose rm api_db
>docker-compose up --build

4. Для проверки наличия созданного volumes, а они храняться в OС компьютера,
останавливаем контейнер ctrl+c
и в консоле набираем
>docker volume
>docker volume ls

  
  
#13 Создадим docker-compose.development.yml для dev-разработки
что бы не перебилдивать докер-проект при внесении каждой правки в код /api/src, в код API-СЕРВИСА,
код, для его сохранности, храним и изменяем в томах данных (где тома - сами папки докер-проекта)
и, после внесения каждых изменений в код express-сервера, перезагружаем api-сервис (express-сервер) с помощью nodemon'a.

1.
//docker-compose.development.yml
version: '3'
services:
  api: 
    command: npm run dev
    volumes:
      - ./api/src:/usr/src/app/src

volumes- без нормального имени, поэтому его нельзя переиспользовать... в других сервисах?
имя у тома - в виде пути
./api/src        - путь на компьютере в папке проекта, относительно места расположения docker-compose.development.yml
/usr/src/app/src - путь до папки /src, находящейся в образе, корень этого пути мы обозначили в поле "WORKDIR /usr/src/app" у Dockerfile.

Поля docker-compose.development.yml перетрут аналогичные поля docker-compose.yml.

2. Команду npm run dev формулируем таким образом(? не понятно...),
что бы сервер перезагружался при каждом сохранении в файлах api-сервиса.
Для этого используем nodemon.

# - nodemon
>npm i nodemon     //из папки  /api
или прописываем ручками в package.json
"dev": {"nodemon": "^2.0.4"}

// api/nodemon.json
{
  "verbose": false,
  "watch": ["src"],             // = на изменение в каких фалах реагировать. src- это папка в сервисе "api"(!).
  "exec": "node src/index.js"   // = какую команду запускать, когда изменяется файл. Здесь- просто перезапускаем express, перезапускаем api-сервис.
} 

3. теперь для запуска docker-compose, что бы запустились ОБА: docker-compose.yml и docker-compose.development.yml, пишем
>docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build

а для продакшина остается по-прежнему
>docker-compose up --build




......................................................
Все это было касаемо кода в папке /api.
Таперь создаем второй сервис: Авторизация, папка /auth.

#14 Сервис Авторизации.

1. По содержанию папка /auth идентична папке /api.
2. Из auth/src/index.js удалим весь код,который касается bd. 
Этот код мы писали только для тестирования работоспособности bd.

3. Прописываем auth-сервис в docker-compose.yml.

Порты пишем иные, чем уже используемые в других сервисах,
    ports:
      - "3002:3002"
      
4. Прописываем сервис auth_db в docker-compose.yml.
5. Билдим и запускаем
>docker-compose up --build

Папка node_modules при билде появляться в проекте не должна.
Она есть в /api, потому что мы express запускали и вне докера.

6. В броузере открываем
http://localhost:8080/test   - API для кода_фронтенда
http://localhost:3002/test   - API для кода_auth




......................................................
#15 Frontend, для dev-работы (урок 14)

Сложности:
- при генерации болванки vue-проекта мы отвечаем на vue-CLI_вопросы, 
- правки в коде проекта обрабатываются by vue-CLI с помощью socket, что докер не поддерживает.

= в терминале, находясь в корне docker_проекта, создаем болванку by vue-CLI,
причем имя проекта даем именно frontend, что бы имя папки проекта выступило в роли имени папки для сервиса.
>vue create frontend

= далее создаем сервис frontend в docker-compose.yml.
1. прописываем сервис
  frontend:
    build: ./frontend
    container_name: It_is_frontend
    ports:
      - "3000:8080"
    restart: unless-stopped
    command: serve -s build -l 3000    //это для продакшн. Для dev-варианта будет 'npm run serve'(vue) или 'npm run start'(react).


2. причесываем левые части прописи портов у сервисов, что бы они у сервисов не повторялись
3. исправляем интерактивную консоль при формировании react-болванки фронта.
https://github.com/facebook/create-react-app, issuer #8688 fails to start in Docker

т.е. добавляем некоторые умные поля в frontend-сервисе у docker-compose.yml (точнее- в docker-compose.development.yml), 
как советуют из выше (для react'a, но срабатывает и для Vue),
    stdin_open: true
    tty: true

4. заявляем Dockerfile внутри frontend-проекта,
он такой же, как и в /api.

FROM node:13.12.0-alpine            //alpine-вариант - это максимально облегченный
WORKDIR /usr/src/app                //в образе обозначаем папку, где будет лежать код образа фронтенда     
COPY package*.json ./               //в корень (т.к. указали ./) образа фронтенда копируем package.json и package-lock.json
RUN npm install                     //инстиллируем зависимости
COPY . .                            //в корень (т.к. указали "вторая .") образа фронтенда копируем все подряд, лежащее по пути "первая .", отталкиваясь от расположения данного Dockerfile. 

5. Для возможности вносить правки в код фронта у образа 
создаем volumes в frontend-сервисе у docker-compose.yml:
   
    volumes:
      - ./frontend/src:/usr/src/app/src   //где -  (см ниже)
      
./frontend/src - что копируем. Изменяемый нами код frontend-проекта. Путь, отталкиваясь от расположения docker-compose.yml. 
/usr/src/app/src - путь к папке  /src в образе frontend-сегмента, 
корень для этого пути мы обозначили в поле "WORKDIR /usr/src/app" у frontend/Dockerfile.

Позже декларацию volumes мы перенесем в docker-compose.development.yml.

6. 
>docker-compose up --build

После внесений правок в код фронта ПЕРЕЗАПУСК ИДЕТ АВТОМАТИЧЕСКИ по socket vue-CLI ,БЕЗ(!) доп наших усилий.

7. Для фронта мы пока не создаем docker-compose.development.yml, т.к. код в болванке фронта - это и есть dev-код.

8. Пишем frontend/Dockerfile для prodaction и для dev по-отдельности.



#16 Frontend для production (урок 15) - docker-compose.development.yml.

1. Переносим часть кода Frontend-сервиса из docker-compose.yml в docker-compose.development.yml
См. также #21 п.3 - в docker-compose.development.yml добавляем сервисы, которые участвуют в nginx-роутинге.

services: 
  frontend:
    command: npm run serve      //это стандартная команда запуска vue_CLI-проекта для dev-работы, для React-CLI будет start.
    stdin_open: true
    tty: true
    volumes:
      - ./frontend/src:/usr/src/app/src
      
2. Билдим Frontend-проект ВРУЧНУЮ(это временно) и генерируем dist-папку в корне Frontend-проекта для деплоя.
Открываем терминал в папке кода фронтенда и запускаем

npm run build

Теперь этот СТАТИЧЕСКИЙ frontend-проект, установив предварительно пакет static-сервера "serve", 
будет можно запустить командой static-сервера

serve -s dist     //для vue
serve -s build    //для react

#3. Устанавливаем static-сервер "serve" на наш компьютер.
npm i -g serve

Проверяем работоспособность static-сервера:
командой в терминале, который открыт в папке Frontend-проекта,
а в этой папке и лежит папка /dist, запускаем сбилденный frontend-проект:

serve -s dist    //dist(vue) или build(react)- это какую папку запускаем в сервере

проект откроется на localhost:5000   //5000 - по-умолчанию для данного сервера

Если проект запустим командой
serve -s dist -l 3000
то он откроется на порту localhost:3000

4. Т.о., когда мы билдим образ Докер-compose, в частности frontend-сервис и frontend/Dockerfile в нем,  
нам необходимо, что бы 
-frontend-проект забилдивался АВТОМАТИЧЕСКИ, т.е. генерировалась папка /dist в корне frontend-проекта,
-в Dockerfile присутствовал и запускался static-сервер "serve".

Для этого:
а) в frontend/Dockerfile у docker-проекта дописываем в конце
RUN npm run build
RUN npm install -g serve

но эти команды нудны только для продакшина, поэтому
позже мы их вынесем куда-то подальше.

б) команду запуска фронта в frontend-сервисе docker-compose.yml меняем с "npm run serve" на 
services:
  frontend:
    command: serve -s build -l 3000          //для React-CLI проекта
    command: serve -s dist -l 3000           //для Vue-CLI проектов. 
    
Путь к dist начинается относительно docker-compose.yml-файла, и далее следуем декларации
services:
  frontend:
    build: ./frontend
    
т.е. получается следующий путь относительно docker-compose.yml-файла: "./frontend/dist".


5. Теперь пересобираем образ и проверяем, работает ли статика frontend-проекта из Докера.
>docker-compose up --build

frontend-проект можно открыть на localhost:3000.

6. Для dev-разработки образ запускаем с применением docker-compose.development.yml (см. #13)
>docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build

В боузере открываем проект по localhost:3000, т.е. 
http://localhost:<your container's external mapped port>/
а не по localhost:8080.
При внесении изменений в код - изменения применяются в броузере автоматически, без перезагрузки докера.



7. См. также #21 и #27.


......................................................
#17 Docker exec (урок 16)

Полезные команды Docker
>docker ps   //процессы, в том числе имена запущенных контейнеров.
>docker exec -it containerName echo "Привет!"  //или container_name у сервиса из docker-compose.yml

- выполняем команду `echo "Привет!"` в линуксе контейнера
- результат выводится в консоле

>docker exec -it containerName sh

-консоль переходит в shell(оболочка) контейнера, в его WORKDIR, т.е. в /usr/src/app
А дальше можно ходить по папкам контейнера

pwd        =>/usr/src/app, путь на "компъютере контейнера", где мы находимся.
ls         => скопированные в контейнер файлы при билдинге контейнера

cd /       => перешли в корень linux
ls         => увидели все папки в корне linux

cd /usr/src/app
npm run server    //запустили контейнерный вариант frontend-проекта. 
Но посмотреть запуск труднее: 
It seems you are running Vue CLI inside a container.
Access the dev server via http://localhost:<your container's external mapped port>/

npm run build

ВЫХОДИТЬ
>Ctrl + d



......................................................
#18  Nginx (урок 17).

Для перенаправления URL-запросов 
sw.ru/       => переходим на frontend-сервис 
sw.ru/api    => переходим на api-сервис 

1.
Сервер имеет в интернете определенный IP, Нр: 144.222.3.444.007.
Когда docker-compose запущен на сервере, то его сервисы-контейнеры проявляются через прописанные в docker-compose порты. 
Нр: frontend-сервис открывается наружу через порт 3000.

Т.о. чтобы попасть на frontend-контейнер надо в интернете набрать 144.222.3.444.007:3000.

2.
После покупки домена мы в его настройках прописываем IP-адрес нашего сервера.
Далее, если набрать sw.ru без указания порта, то на самом деле мы обращаемся by sw.ru:80 
и обращаемся к 80-порту сервера.
Причем порт 80 - будет по-умолчанию и всегда только 80.

3.
Т.е.
набираем sw.ru, попадаем на привязанный к домену IP-адрес нашего сервера, 
причем по-умолчанию идет обращение к 80 порту сервера.

На порту 80 мы запускаем nginx и перенаправляем интернет-запросы на определенный порт сервера, 
по которому открывается определенный docker-compose_сервис.

Что надо для этого сделать:
1. Создаем в docker-compose.yml nginx-сервис.

services:
  nginx:
    image: nginx:stable-alpine
    container_name: dc_nginx
    ports:
      - "80:80"   # nginx в образе будет проявляться в образе своим(nginx-совым) портом 80(справо), и это проявление будет передаваться наружу образа через порт 80 (слево) образа.
    volumes:
      - ./nginx/nginx.conf.prod:/etc/nginx/conf.d/nginx.conf   # для файла конфигурации nginx, см. чуть ниже.
    depends_on:
      - frontend     # что бы frontend-сервис поднимался раньше, чем nginx-сервис.

./nginx/nginx.conf.prod       - физическое расположение в docker-проекте относительно docker-compose.yml
/etc/nginx/conf.d/nginx.conf  - расположение в образе, где его увидит nginx-образа.

2. Если на компъютере уже запущен nginx, то надо его остановить, что бы 80 порт не слушали 2 объекта одновременно.
>ps aux | grep nginx    //проверим, запущен ли на компъютере nginx.

если появиться только 1 строчка, то nginx не запущен
vesna-2+ 25003  0.0  0.0  15652  1012 pts/2    S+   11:45   0:00 grep --color=auto nginx

>service nginx stop    //останавливаем nginx

3.
Для включения автозагрузки Nginx в Ubuntu необходимо в терминале выполнить команду:
>sudo update-rc.d -f nginx enable

Чтобы отключить автозапуск, необходимо выполнить команду:
>sudo update-rc.d -f nginx disable

4. Формируем nginx/nginx.conf.prod
server {
  listen 80;

  server_name sw.ru;

  location / {
    proxy_pass http://frontend:8080;
  }
}

8080 - это аналогично, как прописано в docker-compose.yml
services:
  frontend:
    ports:
      - "3000:8080"
т.е. тот порт внутри frontend-сервиса, через который проявляется frontend-проект,
и далее, при наличии nginx'a, эта строчка "ports" в frontend-сервисе СТАНОВИТСЯ НЕВОСТРЕБОВАННОЙ, лишней.
Мы подменяем "ports: "3000:8080"" by nginx-запросами (см. строку 589).

Итого, через порт 80 docker-compos-образа, 
а именно в него стучиться интернет-запрос и именно его слушает nginx-сервис,  
интернет-запрос попадает в nginx-сервис, 
где nginx, при наличии "/", переправляет нас ПО СЕТИ docker-compos'a by "http://frontend" на frontend-сервис
("http://frontend" - аналог 3000 порта во внешней оболочке frontend-сервиса),
а внутри frontend-сервиса мы ищем его 8080 порт, на который внутри frontend-сервиса стучиться vue-CLI.

5. Запускаем образ
>docker-compose up --build

Но лучше билдить и запускать по-отдельности
>docker-compose build       //сборка-ПЕРЕСБОРКА образа
>docker-compose up          //запуск образа

выборочно просматроваем nginx-логи. Должно быть чисто.
>docker logs dc_nginx


6. SW.RU
Мы можем выйти на nginx docker-проекта через ввод в броузер НАШЕГО компъютера произвольного имени, ПРОПИСАННОГО в /etc/hosts компьютера.
Открываем на компъютере файл 
/etc/hosts  
(на windows - c:\windows\system32\drivers\etc\hosts)
и добавляем в него новую строчку
127.0.0.1 http://sw.ru
или даже просто
127.0.0.1 sw.ru

изменить права доступа к файлу
sudo chmod -R -f 777 ./folder  или fileName
sudo chmod -R -f 777 ./hosts   когда терминал открыт по папке /etc

Т.е., 
когда набираем "sw.ru", то реально набираем "sw.ru:80" и редиректимся на 127.0.0.1:80, что у нас прописано в /etc/hosts.
Одновременно 127.0.0.1 альтернативен и localhost. Поэтому набор в броузере "sw.ru" альтернативен набору localhost:80.

Далее идет 80-порт сети компьютера, который отслеживается и 80-портом docker-образа,
далее запрос ловиться 80-портом запущенного docker-образа (правая 80) и попадет в 80-порт nginx (левая 80).
Далее nginx по аналогии "'/' - 'frontend-сервис'" переходит на frontend-сервис,
а внутри frontend-сервиса слушает его 8080-порт.

Т.е работает цепочка: 
sw.ru:80 броузера - сеть компьютера 80:80 - вход в docker:80 - nginx 80:80 - 
frontend-сервис через docker-сеть - порт 8080 внутри frontend-сервиса (это прописано в настройках nginx - frontend:8080).

Теперь в броузере набираем "sw.ru" и открывается frontend-проект, лежащий в frontend-сервисе.


Строчка в docker-compose.yml
services:
  frontend:
    ports:
      - "3000:8080"
в описанной цепочке не участвует, и ее можно даже удалить (см. строку 528).
Однако, при наличии в\у строчки vue-проект можно будет открыть и как раньше, набрав localhost:3000.

Т.е будет работать цепочка: 
localhost:3000 броузера - сеть компьютера 3000:3000 - docker:3000 - 
а этот порт в docker слушает frontend-сервис и перенаправляет его на свой внутренний порт 8080 (by "3000:8080").


7. Какая еще одна крупная выгода от использования докера и nginx'a в нем:
Строчку
    ports:
      - "3000:8080"
во всех сервисах в docker-compose.yml, кроме nginx-сервиса, эту строчку будем убирать.
К сервисам будет обращение только через nginx-сеть_докера-сервис.

Обычно во frontend-проекте мы обращаемсы к "API-сервера"  sw.ru/api/cars. Т.е. доступ к api публичен.
С докером - мы у сервиса не прописываем никакой порт (смю #20), и поэтому сервис становиться доступен только через сеть докера,
поэтому напрямую снаружи к сервисам не пробрасться, только через SSH на сервер...
...немного не понятно.


 

#19.  
# Nginx-проксирование между сервисами. 
# API запросы от frontend-проекта к api-сервисам.
См. #27 (!).


#A. (Урок 18) Обращение api-сервиса к auth-сервису с запросом о подтверждении авторизации данного юзера.
1. Подготавливаем auth-сервис для принятия запроса.
а) В express в auth/src/index.js добавляем еще один путь для приема запроса и выдачи data
app.get("/api/kola", (req, res) => {
  res.json({
    auth: "kola is confirmed"
  })
})

б) Пересобираем докер
>docker-compose build       //сборка-ПЕРЕСБОРКА образа
>docker-compose up          //запуск образа

в) В броузере при обращении к auth-сервису напрямую, минуя nginx, by адресом
http://localhost:3002/api/kola
появляется надпись
{
auth: "kola is confirmed"
}
т.е. ответ auth-сервиса на запрос авторизации к нему - работает.


2. В api/src/index.js прописываем запрос к auth-сервису.
Сначало api-сервис делает запрос в auth-сервис и затем, когда получит от него подтверждение авторизации, 
api-сервис шлет ответ.

а) Создаем глобальную переменную - адрес обращения сервисов к auth-сервису
и прописываем его среди api-сервис_переменных
// api/src/configuration/index.js
module.exports.authApiUrl = process.env.AUTH_API_URL;

// dicker-compose.yml
services:
  api:
    environment:
      - AUTH_API_URL=http://auth:3002/api   //значение переменной - это префикс у адреса auth-сервиса в рамках docker-сети.  
      
Здесь api-сервис обращается к auth-сервису по docker-сети by URL http://auth:3002/роут_в_auth-express'e,
т.е. при запросе "AUTH_API_URL + '/kola'" мы пойдем на "http://auth:3002/api/kola".
      

б) Декларируем роут в api/src/index.js
const { port, host, db, authApiUrl } = require("./configuration");   //добавили импорт authApiUrl
 
app.get("/testwithcurrentuser", (req, res) => {
    console.log('authApiUrl in api-service ===', authApiUrl);
    res.json({
      testwithcurrentuser: true
    });
});
 
в) Проверяем. Пересобираем докер 
>docker-compose up --build

в броузере по адресу http://localhost:3001/testwithcurrentuser
видим 
{
testwithcurrentuser: true
}, 

а в консоле
после первого обращения браузера к данному URL, или когда перезагрузим страницу броузера,
видим вывод от console.log()
dc_api      | authApiUrl in api-service === http://auth:3002/api


г) ДОБАВЛЯЕМ AXIOS в api-сервис.
Консоль- в папке /api
npm i axios

// api/src/index.js
const axios = require("axios");

и переписываем в api/src/index.js чуть сложней
app.get("/testwithcurrentuser", (req, res) => {
  axios.get(authApiUrl + "/kola")     // пойдем на http://auth:3002/api/kola
    .then(response => {
      res.json({
        testwithcurrentuser: true,
        currentUserFromAuth: response.data
      })
  })
})
 
д) Проверяем. Пересобираем докер
> docker-compose up --build

В броузере набираем
http://localhost:3031/testwithcurrentuser
получаем 
{
  testwithcurrentuser: true,
    currentUserFromAuth: {
      auth: "kola is confirmed"
    }
}



#B. (Урок 19) Внутри-docker-сетевые запросы, продолджение.
0) Подготовка express
npm i body-parser

const bodyParser = require('body-parser')         //(!) Обязателен для всех запросов, которые имеют pl.
app.use(bodyParser.json())



а) Делаем запрос из auth-сервиса к api-сервису.
1. Декларируем переменную окружения со значением api_URL в docker-compose.yml
  auth:
    environment:
      - API_URL=http://api:3001/api      //ЗАЧЕМ добавляет /api, а далее его в запросе НЕ прописывает ??

2. Открываем консоль в папке auth и устанавливаем axios
npm i axios


3. В api-сервисе создаем ОТВЕТ на запрос от auth-сервиса.
//api/src/index.js

app.get("/api/testapidata", (req, res) => {      //  /api - опять не добавил, козел. Но см. урок #20.
  res.json({
    testapidata: true
  });
});
 

4. В auth-сервисе создаем запуск запроса к api-сервису.
//auth/configuration/index.js
module.exports.apiUrl = process.env.API_URL;

//auth/src/index.js
const { apiUrl } = require("./configuration");
const axios = require("axios");

app.get("/testwithapidata", (req, res) => {
  axios.get(apiUrl + "/testapidata").then(response => {      // пойдем на http://api:3001/api/testapidata
    res.json({
      testapidata: response.data.testapidata
    });
  });
});


5. Проверяем
Перезапускаем проект
>docker-compose up --build 
или (когда есть косяк с запосами)
>docker-compose build       //сборка-ПЕРЕСБОРКА образа
>docker-compose up          //запуск образа

В броузере набираем 
localhost:3001/api/testapidata     - ответ получен
localhost:3002/testwithapidata     - ответ получен
{
testapidata: true
}




#С. (Урок 19, вторая часть урока) ИМЕНОВАННАЯ docker-сеть.

>docker network   
>docker network ls  - выведутся все сети

Docker-сети существуют не в рамках конкретного docker-проекта, а в целом в docker-системе.
Поэтому в начало названия сети автоматически добавляется имя docker-проекта, который сгенерировал данную именую docker-сеть.

Более того, сетью my-network далее можно пользоваться by сервисами из других docker-проектов.

1. Декларируем именную сеть в docker-compose.yml

networks:
  my-network:
    driver: bridge
    
2. Подключаем каждый конкретный сервис к my-network, тоже в  в docker-compose.yml.
Если мы не подключим сервис к именованной сети, то он будет по-умолчанию относиться к автоматически создаваемой сети.

  nginx:
    networks:
      - my-network

3. Проверяем
>docker-compose up --build

В броузере набираем 
sw.ru
localhost:3001/api/testapidata
localhost:3002/testwithapidata   

а команда "docker network ls" выдаст данные и по нашей именованной сети:
61557f8550cb  docker_project_default      bridge    local
5e19db9bea7f  docker_project_my-network   bridge    local





#20 (урок 20) Проксирование фронтенда. Запрос из Vue-проекта к docker-сервисам.
Код проекта "оживает" на компьютере пользователя, т.е. ВНЕ докера.
Поэтому запрос из кода фронт-проекта к docker-сервисам делается иначе, чем описано выше.

##А. Напрямую. 
Используем имя_домена(или его IP-адрес сервера, на котором задиплоен проект) и порт docker-compos'a
http//1248.4647.36.65:3001/api

Но здесь связка "имя_домена - его IP-адрес" выступает как кросброузерный запрос (cors)... и пошли сложности.
Во-вторых, ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ, прописанные в докере, доступны на сервере, но не для развернутого на пользователе фронт-проекта.


##Б. Через Nginx (best).
URL для запроса будет простым - axios.get("/api/post"),
без привлечения переменных окружения типа API_URL и без указания IP-сервера.
Frontend-проект ОБРАЩАЕТСЯ на ТЕКУЩИЙ ДОМЕН, по которому проект был запрошен пользователем.

Т.е. Frontend-проект находиться в stateless-состоянии (!).

###1. proxy_pass
// nginx/nginx.conf.prod
   
  location /api {
    proxy_pass http://api:3001;    //запрос sw.ru/api переброситься в docker-сети на его 3001-порт, на котором находиться api-сервис.
    rewrite ^/api/(.*) /$1 break;  //переписываем имя запроса с помощью RE -> это ТО, что попадет в express у api-сервиса.
  }

"sw.ru/api/post" поступает в nginx, а далее server_name не анализируется и отбрасывается.
Т.е. внутри nginx'a мы работаем уже только с "/api/post".
Далее мы переходим по docker-сети на http://api:3001, 
а в api-сервис поступает уже переписанная строка, без "/api"-сегмента.


###2. rewrite
Запрос "sw.ru/api/post" принимается by   
location /api { proxy_pass http://api:3001; }
и далее в express'e у api-сервиса он должен подхватиться by 

app.get("/api/post", (req, res) => {})

Что бы не прописывать в URL'ах api-сервиса тот кусочек URL, который обозначен в "location /api {}" у nginx'a
мы будем в передаваемом для express адресе удалять "/api", 
и одновременно в express'e воспринимаемый URL писать тоже без "/api":

app.get("/post", (req, res) => {})


Для этого в nginx'e прописываем rewrite:

rewrite:
- здесь мы с помощью rewrite переписываем "/api/post" to "/post", выбрасывая /api.
(См. строку 716, 723. Там была типо ошибка.)

То, что в (), в новом варианте строчки вставляется в точку "$1" у нового варианта строки,
".*" означает "повторяющийся любой символ",

"^" - искомый RE дб exactly в начале обрабатываемой строки, иначе эта строка будет игнорироваться.
т.е. "^/api/(.*)" - переписывать будет только такую строку, которая НАЧИНАЕТСЯ с "/api/(.*)".

Итого: строку "/api/(.*)" заменяем на строку "/$1",
       строку "/api/post" заменяем на строку "/post".

 
Одновременно URL в express у api-сервиса пишем тоже БЕЗ /api:

app.get("/testwithcurrentuser", (req, res) => {
})


3. Аналогично делаем для auth-сервиса:

  location /auth/api {
    proxy_pass http://auth:3002;
    rewrite ^/auth/api/(.*) /$1 break;   // строку "/auth/api/post" заменяем на строку "/post".
  }
  
  
4. В docker-compose.yml у nginx-сервиса дописываем в "depends_on" те сервисы, которые задействованы в nginx-роутинге,
что бы nginx стартовал только после них.

services:
  nginx:
    depends_on:
      - frontend
      - api
      - auth


5. Устанавливаем axios в frontend-проекте и 
прописываем запрос (с /api) и БЕЗ указания корневого URL(!):
npm i axios

      axios('/api/testwithcurrentuser')   //БЕЗ указания корневого URL(!).
        .then(response => {
          console.log('response', response.data)
          this.dd = response.data
        })


6. Пробный запуск
> docker-compose up --build 

А) Обращаемся к серверу напрямую, не из кода frontend-проекта:

sw.ru/api/testwithcurrentuser    => 

получаем ответ 
{
  testwithcurrentuser: true,
  currentUserFromAuth: {
    auth: "kola is confirmed"
  }
}

Б) Обращаемся к серверу из кода frontend-проекта:

axios('/api/testwithcurrentuser') 

В network-консоле видим параметры отправленного запроса:
Request URL: http://sw.ru/api/testwithcurrentuser

хотя в запросе "sw.ru" - НЕ УКАЗАН (!), 
и это НЕ КРОСБРОУЗЕРНЫЙ запрос (!).






#21 (урок 21) Чистка проекта.

1. Чистим docker-compose.yml 
a) удаляем из сервисов поле 
ports:
  - "3002:3002"
потому что его функцию взял Nginx.

b) удаляем из сервисов переменную
 - HOST=http://sw.ru
 
т.к. ее мы не используем, она была для демонстрации.
Подобная переменная требуется только для прописывания редиректа на sw.ru




2. Дописываем docker-compose.development.yml
- запуск front-проекта by sw.local
- обновление кода front-проекта в броузере без перезагрузки страницы.

a) добавляем в docker-compose.development.yml те сервисы, которые участвуют в nginx-роутинге.
frontend и api-сервисы уже прописаны, добавляем auth-сервис

  auth:
    command: npm run dev
    volumes:
      - ./auth/src:/usr/src/app/src



b) В docker-compose.yml у nginx-сервиса прописан volumes с отметкой ".prod"
  nginx:
    volumes:
      - ./nginx/nginx.conf.prod:/etc/nginx/conf.d/nginx.conf

поэтому для dev-работы эту строчку заменяем с помощью прописи в docker-compose.development.yml by 
  nginx:
    volumes:
      - ./nginx/nginx.conf.dev:/etc/nginx/conf.d/nginx.conf

и СОЗДАЕМ заявленный нами nginx.conf.dev
Он такой же, как и nginx.conf.prod, но с 1 изменением:

server {
  server_name sw.local;       //было sw.ru
}

а т.к. домена sw.local реально не существует, то для работы nginx'a мы симулируем его, 
ПРОПИСЫВАЯ на локальном компьютере в файле etc/host редирект на  localhost:

127.0.0.1 sw.local

Cм. #18 п.6, строка 559.


с) добавляем в frontend-проект vue.config.js
module.exports = {
  devServer: {
    historyApiFallback: true,
    hot: true,
    inline: true,
    stats: true,
    noInfo: true,
    quiet: true,  
    disableHostCheck: true,  //это самое главное
    host: '0.0.0.0',         //это самое главное
    port: 8080 
  }
};
- работает.

ИЛИ, второй вариант:
vue.config.js - не добавлять,
а проблему исправить в nginx.config.dev, прописав:

        location / {

        proxy_set_header X-Real-IP  $remote_addr;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header Host $host;
        proxy_pass http://xx.xx.xx.xx/;
         }
а конкретнее:    
  location / {
    proxy_set_header X-Real-IP  sw.local;
    proxy_set_header X-Forwarded-For sw.local;
    proxy_set_header Host '0.0.0.0';        
    proxy_pass http://frontend:8080;
  }
- тоже sw.local - сайт открывается,
на начинают непрерывно отправляться XHR и сокет-запросы....  



А НАДО ПРОПИСЫВАТЬ ОДНОВРЕМЕННО:
>1/ //vue.config.js   
   module.exports = {
     devServer: {
       historyApiFallback: true,
       hot: true,
       inline: true,
       stats: true,
       noInfo: true,
       quiet: true,
     
       disableHostCheck: true,  //это самое главное
       host: '0.0.0.0',         //это самое главное
       port: 8080 
     }
   };

>2/ // nginx.config.dev
  location / {
    proxy_set_header X-Real-IP  sw.local;
    proxy_set_header X-Forwarded-For sw.local;
    proxy_set_header Host '0.0.0.0';

    proxy_pass http://frontend:8080;

    # Needed for sockets
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
  }


=>>
= http://sw.local/   -> сайт - открывается
= обновление кода в front-проекте без перезагрузки броузера
= НЕТ WS (т.е. сокет-соединения) в network-консоли, хотя у Монстра оно, хоть и 1 штука, но - возникает,
= обновление кода в броузере идет по http://sw.local/2a7b2474d30de6641402.hot-update.json-XHR-запросу.




d) Из папок api и auth удаляем папку node_modules
т.к. "снаружи" контейнера она не нужна, но может приводить к ошибкам при билдинге контейнера.



e) Для проверки dev-режима запускаем 
>docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build

В броузере набираем
sw.local
sw.local/api/testwithcurrentuser

=> frontend-проект - запускается, изменения в коде применяются без перезагрузки броузера.
=> ответ от api - получаем.




3. Пишем frontend/Dockerfile для prodaction и для dev по-отдельности.
У нас прописано

RUN npm run build
RUN npm install -g serve

но оно требуется только для prodaction.

a) Переименовываем frontend/Dockerfile в frontend/Dockerfile.prod
b) В docker-compose.yml меняем строчку

services:
  frontend:
    build: ./frontend
на

services:
  frontend:
    build:
      dockerfile: Dockerfile.prod
      context: ./frontend
    

с) Создаем такой же Dockerfile.dev и убираем из него 

RUN npm run build
RUN npm install -g serve

d) В docker-compose.development.yml добавляем строчку
services:
  frontend:
    build:
      dockerfile: Dockerfile.dev
      context: ./frontend







#22. Почтовый сервис.
- сделай сам.

1. на базе express
2. без bd






#23. Варианты деплоя проекта.

А. Сохраняем docker-проект на dockerHub.
hub.docker.com

>docker images | grep docker_project
- получим созданные нашим docker-проектом образы:
docker_project_frontend   latest              8baa35597825        About an hour ago   314MB
docker_project_api        latest              eeed998b167f        4 hours ago         128MB
docker_project_auth       latest              1572e1bcba2e        10 days ago         128MB

для bd и для nginx мы не создавали образ, а брали уже готовый из dockerHub'a,
поэтому они здесь не фигурируют.

Поэтому эти три образа можно сохранить на dockerHub, 
а далее на любом сервере скачать by pull
и, НЕ БИЛДЯ, сразу использовать.



Б. Помещаем весь код в gitLab или gitHub.
Сохраняем просто код, без докера, без образов и т.д.

Находясь на боевом сервере совершить git pull
и далее ЗАПУСТИТЬ 
> docker-compose up --build

и - все.
Но не для оч. крупных проектов, т.к. есть засады в процессе билдинга:
-  может не сработать в полной мере npm install, прописанный в Dockerfile'ах.

Дополнительно, для подстраховки, надо прописывать в Dockerfile'ах 
ТОЧНЫЕ ВЕРСИИ(!) всего подряд.
Нр:
FROM node:13.12.0-alpine




#24. ДЕПЛОИМ docker-проект через gitLab и UBUNTU сервера.

1. заливаем проект на gitLab.
2. нужен сервер с установленным на нем Linux с docker и docker-compos'ом.
Здесь в роли сервера может пойти ноутбук с Ubuntu 18.04.

Монстр использует сервер с Linux'ом - hetzner.com/cloud
3. Создаем сервер:
- на базе Ubuntu 18.04
- стандартный тип
- без: volume, network, add features, SSH_key
- вводим свое придуманное название сервера

Нам вышлют пароль для рутового пользователя Ubunt'ы. 
Но, по-хорошему, лучше создать Ubunt'е отдельного пользователя с ограниченными правами - с правом работать только с docker'ом.

Будет указан IP-адрес нашего сервера.

Открываем консоль и загонем
>ssh root@IP-адрес_сервера
yes
вводим рутовый пароль, который мы получили в письме

меняем пароль:
>вводим текущий пароль
>вводим новый пароль 2 раза

консоль переходит внутрь Ubunt'ы сервера.


4. УСТАНАВЛИВАЕМ docker и docker-compos на Ubunt'у сервера.
https://community.hetzner.com/tutorials/deploy-nodejs-with-docker
Это Step_4.
По этой схеме можно ставить docker и на Ubuntu ноутбука.

NB!
После установки docker-compos добавляем текущего юзера Убунты в группу Докера что бы мы могли выполнять docker-команды.
НО ВМЕСТО предложенной строчки

>sudo gpasswd -a myuser docker     //здесь "docker" - это группа "docker".

в консоль вводим строчку
>sudo gpasswd -a root docker
 
но здесь, повторяемся, лучше использавать не root-пользователя, а создать в Убунте дополнительного юзера.

(далее в туториале по установке дакера и композа идет строчка "docker --version")

  

5. Перенос проекта с gitLab и его развертывание на ubunt'e сервера.

>pwd                          //переход в корень убунты
>cd /root                     //прешли в домашнюю папку текущего юзера
>mkdir projects
>apt-get install git          //устанавливаем git на убунту

>ssh-keygen                   //генерируем SSH-ключи
>ls /root/.ssh/
>vi /root/.ssh/id_rsa.pub       //открываем публичный ключ и копируем его в gitLab with vim

>git clone .......git         //копируем в gitLab'e ссылку для клонирования with SSH и клонируем, находясь в /projects.

>docker-compose build
>docker-compose up



6. Проверка
Уточняем IP-адрес сервера в аккаунте hetzner.com

Вносим в etc/hosts строчку
IP-адрес_сервера sw.com

Это аналогичный маневр, если бы мы КУПИЛИ ДОМЕН И ПРИКРЕПИЛИ ЕГО к данному IP-адресу_сервера.

На компьютере, вне серверной убунты, вводим в броузере
sw.com
=> открывается наш сайт.



7. Что бы консоль в серверной убунте не была постоянно занятой работающим докером
>CTRL C                 //останавливаем контейнер
>docker-compose up -d   //перезапускаем с флагом "detached"

Таперь докер работает фоново, а в ЭТОМ ЖЕ окне консоли можно вводить иные команды.
>docker ps             //процессы докера
>docker logs
>docker logs имя_образа
-> будет указано в частности
Our hosts is undefined   //потому что мы убрали hosts из переменных окружения, а проект - stateLess'ный.






#26. Чистка системы от шмaтков докера.

>docker image ls    //список образов на компьютере

Здесь есть куча временных технических образов <none>, которые докер создает автоматически, но за собой не убирает.

>docker system           //список системных команд
>docker system prune     //чистка
 This will remove:
   - all stopped containers
   - all networks not used by at least one container
   - all dangling images
   - all dangling build cache
Соглашаемся Yes спокойно

"docker system prune" периодически надо делать и на продакшине.




#27. Дополнения, которые я внес в проект самостоятельно.

1. Что бы запросы с фронта оставались stateless-овыми, но без прописывания на ноутбуке в файле etc/hosts синонимов для IP-адреса ноутбука
- в docker_Monstr_project/nginx/nginx.conf.dev я прописал
  server_name localhost;
  
- в Docker_monstr/docker_Monstr_project/docker-compose.development.yml я прописал
  nginx:
    volumes:
      - ./nginx/nginx.conf.dev:/etc/nginx/conf.d/default.conf   #  именно default.conf
  
а фронт для dev-работы надо открывать по адресу
http://localhost/
или
http://localhost:80    ТОЛЬКО(!)

хотя он будет открываться и непосредственно, минуя nginx, по адресу
http://localhost:3000
но axios-запросы срабатывать не будут(!).

По большому счету фронт-проект будет открываться в броузере и по localhost:3000, что прописано в docker-compose.yml,
но тогда axios-запрос axios.get('/api'), являясь stateless-ным, будет направляться по адресу localhost:3000/api,
не попадет в ngnix, который слушает :80-порт, а попадет непосредственно в порты, прописанные у сервисов в docker-compose.yml.
А там на :3000 висит сервис frontend, а нам требуется попасть к api-сервису, который слушает 3001-порт...,
и поэтому axios-запрос не найдет свою цель.

Здесь же stateless-запрос будет захватяваться by :80 портом, который слушает nginx.
А nginx, в свою очередь, перенаправит запрос в api-сервис.
Все работать будет.



